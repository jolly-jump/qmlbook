# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2014 JÃ¼rgen Bocklage-Ryannel and Johan Thelin. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License
# This file is distributed under the same license as the Qt5 Cadaques Book package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qt5 Cadaques Book 2015-03\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-24 23:30+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Language-Team: German (https://www.transifex.com/qmlbook/teams/82765/de/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: de\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../ch16/index.rst:3
msgid "Extending QML with C++"
msgstr ""

#: ../../ch16/index.rst:11
msgid "Last Build: |today|"
msgstr ""

#: ../../ch16/index.rst:13
msgid ""
"The source code for this chapter can be found in the `assets folder "
"<../../assets>`_."
msgstr ""

#: ../../ch16/index.rst:16
msgid ""
"Executing QML within the confined space that QML as a language offers can "
"sometimes be limiting. By extending the QML run-time with native "
"functionality written in C++, the application can utilize the full "
"performance and freedom of the base platform."
msgstr ""

#: ../../ch16/index.rst:19
msgid "Understanding the QML Run-time"
msgstr ""

#: ../../ch16/index.rst:23
msgid ""
"When running QML, it is being executed in a run-time environment. The run-"
"time is implemented in C++ in the ``QtQml`` module. It consists of an "
"engine, responsible for the execution of QML, contexts, holding the "
"properties accessible for each component, and components, the instantiated "
"QML elements."
msgstr ""

#: ../../ch16/index.rst:30
msgid ""
"In the example the ``QGuiApplication`` encapsulates all that is related to "
"the application instance (e.g. application name, command line arguments and "
"managing the event loop). The ``QQmlApplicationEngine`` manages the "
"hierarchical order of contexts and components. It requires typical a qml "
"file to be loaded as the starting point of your application. In this case it"
" is a ``main.qml`` containing a window and a text type."
msgstr ""

#: ../../ch16/index.rst:34
msgid ""
"Loading a ``main.qml`` with a simple ``Item`` as the root type through the "
"``QmlApplicationEngine`` will not show anything on your display, as it "
"requires a window to manage a surface for rendering. The engine is capable "
"of loading qml code which does not contain any user interface (e.g plain "
"objects). Because of this it does not create a window for you by default. "
"The ``qmlscene`` or the new ``qml`` runtime will internally first check if "
"the main qml file contains a window as a root item and if not create one for"
" you and set the root item as a child to the newly created window."
msgstr ""

#: ../../ch16/index.rst:39
msgid ""
"In the qml file we declare our dependencies here it is ``QtQuick`` and "
"``QtQuick.Window``. These declaration will trigger a lookup for these "
"modules in the import paths and on success will load the required plugins by"
" the engine. The newly loaded types will then be made available to the qml "
"file controlled by a qmldir."
msgstr ""

#: ../../ch16/index.rst:41
msgid ""
"Is it also possible to shortcut the plugin creation by adding our types "
"directly to the engine. Here we assume we have a ``CurrentTime`` ``QObject``"
" based class."
msgstr ""

#: ../../ch16/index.rst:51
msgid "Now we can also use the ``CurrentTime`` type in our qml file."
msgstr ""

#: ../../ch16/index.rst:62
msgid ""
"For the really lazy there is also the very direct way through context "
"properties."
msgstr ""

#: ../../ch16/index.rst:77
msgid ""
"Do not mix up ``setContextProperty()`` and ``setProperty()``. The first on "
"sets a context property on a qml context, and ``setProperty()`` sets a "
"dynamic property value on a ``QObject`` and will not help you."
msgstr ""

#: ../../ch16/index.rst:79
msgid ""
"Now you can use the current property everywhere in your application. Thanks "
"to context inheritance."
msgstr ""

#: ../../ch16/index.rst:97
msgid "Here are the different ways you can extend QML in general:"
msgstr ""

#: ../../ch16/index.rst:99
msgid "Context properties - ``setContextProperty()``"
msgstr ""

#: ../../ch16/index.rst:101
msgid ""
"Register type with engine - calling ``qmlRegisterType`` in your main.cpp"
msgstr ""

#: ../../ch16/index.rst:103
msgid "QML extension plugins - To be discussed next"
msgstr ""

#: ../../ch16/index.rst:105
msgid ""
"**Context properties** are easy to use for small applications. They do not "
"require many effort you just expose your system API with kind of global "
"objects. It is helpful to ensure there will be no naming conflicts (e.g by "
"using a special character for this (``$``) for example ``$.currentTime``). "
"``$`` is a valid character for JS variables."
msgstr ""

#: ../../ch16/index.rst:107
msgid ""
"**Registering QML types** allows the user to control the lifecycle of an c++"
" object from QML. This is not possible with the context properties. Also it "
"does not pollute the global namespace. Still all types need to be registered"
" first and by this all libraries need to be linked on application start, "
"which in most cases is not really a problem."
msgstr ""

#: ../../ch16/index.rst:109
msgid ""
"The most flexible system is provided by the **QML extension plugins**. They "
"allow you to register types in a plugin which is loaded when the first QML "
"file calls the import identifier. Also by using a QML singleton there is no "
"need to pollute the global namespace anymore. Plugins allow you to reuse "
"modules across projects, which comes quite handy when you do more than one "
"project with Qt."
msgstr ""

#: ../../ch16/index.rst:111
msgid ""
"For the remainder of this chapter will focus on the qml extension plugins. "
"As they provide the greates flexibility and reuse."
msgstr ""

#: ../../ch16/index.rst:114
msgid "Plugin Content"
msgstr ""

#: ../../ch16/index.rst:116
msgid ""
"A plugin is a library with a defined interface, which is loaded on demand. "
"This differs from a library as a library is linked and loaded on startup of "
"the application. In the QML case the interface is called "
"``QQmlExtensionPlugin``. There are two methods interesting for us "
"``initializeEngine()`` and ``registerTypes()``. When the plugin is loaded "
"first the ``initializeEngine()`` is called, which allows us to access the "
"engine to expose plugin objects to the root context. In the majority you "
"will only use the ``registerTypes()`` method. This allows you to register "
"you custom QML types with the engine on the provided url."
msgstr ""

#: ../../ch16/index.rst:118
msgid ""
"Let us step back a little bit and think about a potential file IO type which"
" would allow us to read/write small text files form QML. A first iteration "
"could look like this in a mocked QML implementation."
msgstr ""

#: ../../ch16/index.rst:128
msgid ""
"This is a pure qml implementation of a possible C++ based QML API for "
"exploring an API. We see we should have a read and write function. Where the"
" write function takes a path and a text and the read function takes a path "
"and returns a text. As it looks path and text are common parameters and "
"maybe we can extract them as properties."
msgstr ""

#: ../../ch16/index.rst:140
msgid ""
"Yes this looks more like a QML API. We use properties to allow our "
"environment to bind to our properties and react on changes."
msgstr ""

#: ../../ch16/index.rst:142
msgid ""
"To create this API in C++ we would need to create an interface something "
"like this."
msgstr ""

#: ../../ch16/index.rst:157
msgid ""
"This ``FileIO`` type need to be registered with the QML engine. We want to "
"use it under the \"org.example.io\" module"
msgstr ""

#: ../../ch16/index.rst:166
msgid ""
"A plugin could expose several types with the same module. But it can not "
"expose several modules from one plugin. So there is a one to one "
"relationship between modules and plugins. This relationship is expressed by "
"the module identifier."
msgstr ""

#: ../../ch16/index.rst:169
msgid "Creating the plugin"
msgstr ""

#: ../../ch16/index.rst:171
msgid ""
"Qt Creator contains a wizard to create a **QtQuick 2 QML Extension Plugin** "
"we use it to create a plugin called ``fileio`` with a ``FileIO`` object to "
"start with in the module **\"org.example.io\"**."
msgstr ""

#: ../../ch16/index.rst:173
msgid ""
"The plugin class is dervived from ``QQmlExtensionPlugin`` and implements the"
" ``registerTypes()`` function. The ``Q_PLUGIN_METADATA``  line is mandatory "
"to identify the plugin as an qml extension plugin. Besides this there is "
"nothing spectacular going on."
msgstr ""

#: ../../ch16/index.rst:193
msgid ""
"In the implementation of the ``registerTypes`` we simply register our "
"``FileIO`` class using the ``qmlRegisterType`` function."
msgstr ""

#: ../../ch16/index.rst:208
msgid ""
"Interestingly we can not see here the module URI (e.g. **org.example.io**). "
"This seems to be set from the outside."
msgstr ""

#: ../../ch16/index.rst:210
msgid ""
"When you look into your project directory you will find a qmldir file. This "
"file specifies the content of your qml plugin or better the QML side of your"
" plugin. It should look like this for you."
msgstr ""

#: ../../ch16/index.rst:217
msgid ""
"The module is the URI under which your plugin is reachable by others and the"
" plugin line must be identical with your plugin file name (under mac this "
"would be *libfileio_debug.dylib* on the file system and *fileio* in the "
"*qmldir*). These files where created by Qt Creator based on the given "
"information. The module uri is also available in the .pro file. There is is "
"used to build up the install directory."
msgstr ""

#: ../../ch16/index.rst:219
msgid ""
"When you call ``make install`` in your build folder the library will be "
"copied into the Qt ``qml`` folder (for Qt 5.4 on mac this would be "
"*\"~/Qt/5.4/clang_64/qml\"*. The exact path depends on you Qt installation "
"location and the used compiler on your system). There you will find a the "
"library inside the \"org/example/io\" folder. The content are these two "
"files currently"
msgstr ""

#: ../../ch16/index.rst:226
msgid ""
"When importing a module called \"org.example.io\", the qml engine will look "
"in one of the import paths and tries to locate the \"org/example/io\" path "
"with a qmldir. The qmldir then will tell the engine which library to load as"
" a qml extension plugin using which module URI. Two modules with the same "
"URI will override each other."
msgstr ""

#: ../../ch16/index.rst:229
msgid "FileIO Implementation"
msgstr ""

#: ../../ch16/index.rst:231
msgid ""
"The ``FileIO`` implementation is straightforward. Remember the API we want "
"to create should look like this."
msgstr ""

#: ../../ch16/index.rst:246
msgid ""
"We will leave out the properties, as they are simple setters and getters."
msgstr ""

#: ../../ch16/index.rst:248
msgid ""
"The read method opens a file in read mode and reads the data using a text "
"stream."
msgstr ""

#: ../../ch16/index.rst:269
msgid ""
"When the text is changed it is necessary to inform others about the change "
"using ``emit textChanged(m_text)``. Otherwise property binding will not "
"work."
msgstr ""

#: ../../ch16/index.rst:271
msgid ""
"The write method does the same but opens the file in write mode and uses the"
" stream to write the contents."
msgstr ""

#: ../../ch16/index.rst:287
msgid ""
"Do not forget to call ``make install`` at the end. Otherwise your plugin "
"files will not be copied over to the qml folder and the qml engine will not "
"be able to locate the module."
msgstr ""

#: ../../ch16/index.rst:289
msgid ""
"As the reading and writing is blocking you should only use this ``FileIO`` "
"for small texts, otherwise you will block the UI thread of Qt. Be warned!"
msgstr ""

#: ../../ch16/index.rst:292
msgid "Using FileIO"
msgstr ""

#: ../../ch16/index.rst:294
msgid ""
"Now we can use our newly created file to access some nice data. For this "
"example we want to read some city data in a JSON format and display it in a "
"table. We will use two projects, one the extension plugin (called "
"``fileio``) which provides us a way to read and write text from a file and "
"the other one, which displays the data in a table (``CityUI``) by using the "
"file io for reading and writing of files. The data used in this example is "
"in the ``cities.json`` file."
msgstr ""

#: ../../ch16/index.rst:298
msgid ""
"JSON is just text, which is formatted in such a way that it can be converted"
" into a valid JS object/array and back to text. We use our ``FileIO`` to "
"read the JSON formatted data and convert it into a JS object using "
"``JSON.parse()``. The data is later used as a model to the table view. This "
"is roughly the content of our read document function. For saving we convert "
"the data back into a text format and use the write function for saving."
msgstr ""

#: ../../ch16/index.rst:300
msgid ""
"The city JSON data is a formatted text file, with a set of city data "
"entries, where each entry contains interesting data about the city."
msgstr ""

#: ../../ch16/index.rst:316
msgid "The Application Window"
msgstr ""

#: ../../ch16/index.rst:318
msgid ""
"We use the Qt Creator ``QtQuick Application`` wizard to create a Qt Quick "
"controls based application. We will not use the new QML forms as this is "
"difficult to explain in a book, although the new forms approach with a "
"*ui.qml* file is much more usable than previous. So you can remove/delete "
"the forms file for now."
msgstr ""

#: ../../ch16/index.rst:320
msgid ""
"The basic setup is an ``ApplicationWindow`` which can contain a toolbar, "
"menubar and statusbar. We will only use the menubar to create some standard "
"menu entries for opening and saving the document. The basic setup will just "
"display an empty window."
msgstr ""

#: ../../ch16/index.rst:339
msgid "Using Actions"
msgstr ""

#: ../../ch16/index.rst:341
msgid ""
"To better use/reuse our commands we use the QML ``Action`` type. This will "
"allow us later to use the same action also for a potential tool bar. The "
"open and save and exit actions are quit standard. The open and save action "
"do not contain any logic yet, this we will come later. The menubar is "
"created with a file menu and these three action entries. Additional we "
"prepare already a file dialog, which will allow us to pick our city document"
" later. A dialog is not visible when declared, you need to use the "
"``open()`` method to show it."
msgstr ""

#: ../../ch16/index.rst:385
msgid "Formatting the Table"
msgstr ""

#: ../../ch16/index.rst:387
msgid ""
"The content of the city data shall be displayed in a table. For this we use "
"the ``TableView`` control and declare 4 columns: city, country, area, "
"population. Each column is a standard ``TableViewColumn``. Later we will add"
" columns for the flag and remove operation which will require a custom "
"column delegate."
msgstr ""

#: ../../ch16/index.rst:416
msgid ""
"Now the application should show you a menubar with a file menu and an empty "
"table with 4 table headers. The next step will be to populate the table with"
" useful data using our *FileIO* extension."
msgstr ""

#: ../../ch16/index.rst:420
msgid ""
"The ``cities.json`` document is an array of city entries. Here is an "
"example."
msgstr ""

#: ../../ch16/index.rst:436
msgid ""
"Our job is it to allow the user to select the file, read it, convert it and "
"set it onto the table view."
msgstr ""

#: ../../ch16/index.rst:439
msgid "Reading Data"
msgstr ""

#: ../../ch16/index.rst:441
msgid ""
"For this we let the open action open the file dialog. When the user has "
"selected a file the ``onAccepted`` method is called on the file dialog. "
"There we call the ``readDocument()`` function. The ``readDocument()`` "
"function sets the url from the file dialog to our ``FileIO`` object and "
"calls the ``read()`` method. The loaded text from ``FileIO`` is then parsed "
"using the ``JSON.parse()`` method and the resulting object is directly set "
"onto the table view as a model. How convenient is that."
msgstr ""

#: ../../ch16/index.rst:476
msgid "Writing Data"
msgstr ""

#: ../../ch16/index.rst:478
msgid ""
"For saving the document, we hook up the save action to the "
"``saveDocument()`` function. The save document function takes the model from"
" the view, which is a JS object and converts it into a string using the "
"``JSON.stringify()`` function. The resulting string is set to the text "
"property of our ``FileIO`` object and we call ``write()`` to save the data "
"to disk. The \"null\" and \"4\" paramters on the ``stringify`` function will"
" format the resulting JSON data using indentation with 4 spaces. This is "
"just for better reading of the saved document."
msgstr ""

#: ../../ch16/index.rst:501
msgid ""
"This is basically the application with reading, writing and displaying a "
"JSON document. Think about all the time spend by writing XML readers and "
"writers. With JSON all you need is a way to read and write a text file or "
"send receive a text buffer."
msgstr ""

#: ../../ch16/index.rst:507
msgid "Finishing Touch"
msgstr ""

#: ../../ch16/index.rst:509
msgid ""
"The application is not fully ready yet. We still want to show the flags and "
"allow the user to modify the document by removing cities from the model."
msgstr ""

#: ../../ch16/index.rst:511
msgid ""
"The flags are stored for this example relative to the ``main.qml`` document "
"in a *flags* folder. To be able to show them the table column needs to "
"define a custom delegate for rendering the flag image."
msgstr ""

#: ../../ch16/index.rst:527
msgid ""
"That is all. It exposes the flag property from the JS model as "
"``styleData.value`` to the delegate. The delegate then adjust the image path"
" to pre-pend ``'flags/'`` and displays it."
msgstr ""

#: ../../ch16/index.rst:529
msgid "For removing we use a similar technique to display a remove button."
msgstr ""

#: ../../ch16/index.rst:545
msgid ""
"For the data removal operation we get hold on the view model and then remove"
" one entry using the JS ``splice`` function. This method is available to us "
"as the model is from the type JS array. The splice method changes the "
"content of an array by removing existing elements and/or adding new "
"elements."
msgstr ""

#: ../../ch16/index.rst:547
msgid ""
"A JS array is unfortunately not so smart as a Qt model like the "
"``QAbstractItemModel``, which will notify the view about row changes or data"
" changes. The view will not show any updated data by now as it is never "
"notified about any changes. Only when we set the data back to the view, the "
"view recognizes there is new data and refreshes the view content. Setting "
"the model again using ``view.model = data`` is a way to let the view know "
"there was a data change."
msgstr ""

#: ../../ch16/index.rst:552
msgid "Summary"
msgstr ""

#: ../../ch16/index.rst:554
msgid ""
"The plugin created is a very simple plugin but it can be re-used now and "
"extended by other types for different applications. Using plugins creates a "
"very flexible solution. For example you can now start the UI by just using "
"the ``qmlscene``. Open the folder where your ``CityUI`` project is an start "
"the UI with ``qmlscene main.qml``. I really encourage you to write your "
"applications in a way so that they work with a ``qmlscene``. This has a "
"tremendous increase in turnaround time for the UI developer and it is also a"
" good habbit to keep a clear separation."
msgstr ""

#: ../../ch16/index.rst:556
msgid ""
"Using plugins has one drawback the deployment gets more difficult for simple"
" applications. You need now to deploy your plugin with your application. If "
"this is a problem for you you can still use the same ``FileIO`` object to "
"register it directly in your ``main.cpp`` using ``qmlRegisterType``. The QML"
" code would stay the same."
msgstr ""

#: ../../ch16/index.rst:558
msgid ""
"Often in larger projects you do not use an application as such. You have a "
"simple qml runtime similar to ``qmlscene`` and require all native "
"functionality to come as plugins. And your projects are simple pure qml "
"projects using these qml extension plugins. This provides a great "
"flexibility and removes the compilation step for UI changes. After editing a"
" QML file you just need to run the UI. This allows the user interface "
"writers to stay flexible and agile to make all these little changes to push "
"pixels."
msgstr ""

#: ../../ch16/index.rst:560
msgid ""
"Plugins provide a nice and clean separation between C++ backend development "
"and QML frontend development. When developing QML plugins always have the "
"QML side in mind and do not hesitate to start with a QML only mockup first "
"to validate your API before you implement it in C++. If an API is written in"
" C++ people often hesitate to change it or not to speak of to rewrite it. "
"Mocking an API in QML provides much more flexibility and less initial "
"investment. When using plugins the switch between a mocked API and the real "
"API is just changing the import path for the qml runtime."
msgstr ""
